<?php

namespace clear;

require_once __DIR__ . "/../BaseUnitTestCase.php";

/**
 * Test class for ExtractingClosure.
 * Generated by PHPUnit on 2011-12-13 at 08:27:29.
 */
class ExtractingClosureUnitTest extends \BaseUnitTestCase {

    public function testConstructNoExplosions()
    {
        new ExtractingClosure(function(){});
    }
    
    public function testEmptyInitClosureExtractsEmptyArray()
    {
        $init_closure = function(){};
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertEquals(array(), $extracting_closure(),
            'Since $init_closure = function(){}; the extraction should deliver an empty'
            .' array not ['.print_r($extraction,true).']');
    }
    public function testInitClosureWithScalarInScopeExtractedToArray()
    {
        $init_closure = function(){ $x = 1;};
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertEquals(array("x"=>1), $extracting_closure(),
            'Since $init_closure = function(){$x = 1;}; the extraction should deliver'
            .' array("x"=>1) not ['.print_r($extraction,true).']');
    }
    public function testInitClosureWithScalarVarTypeIsPreservedInExtraction()
    {
        $init_closure = function(){ $x = 1;};
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertTrue(is_integer($extraction['x']),
            'The returned value of $x should have been and integer'
            .' $x: ['.print_r($extraction['x'], true).']');
    }
    public function testInitClosureWithNonScalarExtraction()
    {
        $init_closure = function(){ 
            $array = array('one');
            $date  = new \DateTime('now');
        };
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertTrue(is_array($extraction['array']),
            'The returned value of $array should have been an array'
            .' $array: ['.print_r($extraction['array'], true).']');
        $this->assertTrue(is_a($extraction['date'], 'DateTime'),
            'The returned value of $date should have been a DateTime'
            .' $array: ['.print_r($extraction['date'], true).']');
    }
    
    public function testEmptyInitClosureSentScopeVarsExtractionReturnsScopeVars()
    {
        $init_closure = function(){};
        $scope_var = array('x' => 'Hello World');
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform($scope_var);
        $extracting_closure();
        $this->assertEquals(array('x'=>'Hello World'), $extracting_closure(),
            'Extraction should deliver an'
            .' array("x" => "Hello World") not ['.print_r($extracting_closure(), true).']');
    }
    
    public function testInitClosureHasAccessToScopeVars()
    {
        $init_closure = function(){
            $message = "Hello {$x}";
        };
        $scope_var = array('x' => 'World');
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform($scope_var);
        $extracting_closure();
            $this->assertEquals(array(
                'message'=>'Hello World',
                'x' => 'World'
            ),
            $extracting_closure()
        );
    }
    /**
     * @expectedException \InvalidArgumentException
     */
    public function testProtectedScopeVarNamesDissalowed()
    {
        $init_closure = function(){};
        $scope_var = array('this' => 'should not take over $this');
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform($scope_var);
    }
    /**
     * @expectedException \InvalidArgumentException
     */
    public function testNonValidScopeVarNamesDissalowed()
    {
        $init_closure = function(){};
        $scope_var = array('2b' => '2b is not a valid var name');
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform($scope_var);
    }
    /**
     * @expectedException \InvalidArgumentException
     */
    public function testNonValidScopeVarNameDigitsDissalowed()
    {
        $init_closure = function(){};
        $scope_var = array(0 => '0 is not a valid var name');
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform($scope_var);
    }
}