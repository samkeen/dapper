<?php
namespace dapper;
require_once __DIR__ . "/../BaseCase.php";

/**
 * Test class for ExtractingClosure.
 * Generated by PHPUnit on 2011-12-13 at 08:27:29.
 */
class ExtractingClosureTest extends \BaseCase {

    function testConstructNoExplosions()
    {
        new ExtractingClosure(function(){});
        // Success, no errors
        $this->assertTrue(true);
    }
    
    function testEmptyInitClosureExtractsEmptyArray()
    {
        $init_closure = function(){};
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertEquals(array(), $extracting_closure(),
            'Since $init_closure = function(){}; the extraction should deliver an empty'
            .' array not ['.print_r($extraction,true).']');
    }
    function testInitClosureWithScalarInScopeExtractedToArray()
    {
        $init_closure = function(){ $x = 1;};
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertEquals(array("x"=>1), $extracting_closure(),
            'Since $init_closure = function(){$x = 1;}; the extraction should deliver'
            .' array("x"=>1) not ['.print_r($extraction,true).']');
    }
    function testInitClosureWithScalarVarTypeIsPreservedInExtraction()
    {
        $init_closure = function(){ $x = 1;};
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertTrue(is_integer($extraction['x']),
            'The returned value of $x should have been and integer'
            .' $x: ['.print_r($extraction['x'], true).']');
    }
    function testInitClosureWithNonScalarExtraction()
    {
        $init_closure = function(){ 
            $array = array('one');
            $date  = new \DateTime('now');
        };
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform();
        $extraction = $extracting_closure();
        $this->assertTrue(is_array($extraction['array']),
            'The returned value of $array should have been an array'
            .' $array: ['.print_r($extraction['array'], true).']');
        $this->assertTrue(is_a($extraction['date'], 'DateTime'),
            'The returned value of $date should have been a DateTime'
            .' $array: ['.print_r($extraction['date'], true).']');
    }
    
    function testEmptyInitClosureSentScopeVarsExtractionReturnsScopeVars()
    {
        $init_closure = function(){};
        $scope_var = array('x' => 'Hello World');
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform($scope_var);
        $extracting_closure();
        $this->assertEquals(array('x'=>'Hello World'), $extracting_closure(),
            'Extraction should deliver an'
            .' array("x" => "Hello World") not ['.print_r($extracting_closure(), true).']');
    }
    
    function testInitClosureHasAccessToScopeVars()
    {
        $init_closure = function(){
            $message = "Hello {$x}";
        };
        $scope_var = array('x' => 'World');
        $extracto = new ExtractingClosure($init_closure);
        $extracting_closure = $extracto->transform($scope_var);
        $extracting_closure();
            $this->assertEquals(array(
                'message'=>'Hello World',
                'x' => 'World'
            ),
            $extracting_closure()
        );
    }
    /**
     * @expectedException \InvalidArgumentException
     */
    function testProtectedScopeVarNamesDissalowed()
    {
        $init_closure = function(){};
        $scope_var = array('this' => 'should not take over $this');
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform($scope_var);
    }
    /**
     * @expectedException \InvalidArgumentException
     */
    function testNonValidScopeVarNamesDissalowed()
    {
        $init_closure = function(){};
        $scope_var = array('2b' => '2b is not a valid var name');
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform($scope_var);
    }
    /**
     * @expectedException \InvalidArgumentException
     */
    function testNonValidScopeVarNameDigitsDissalowed()
    {
        $init_closure = function(){};
        $scope_var = array(0 => '0 is not a valid var name');
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform($scope_var);
    }
    
    function testNewClosureCodeProperForMinimalClosure()
    {
        $init_closure = function(){};
        $extracto = new ExtractingClosure($init_closure);
        $closure_code = $extracto->build_closure_code_string(array());
        $this->assertEquals("function() {\nreturn get_defined_vars();\n}", $closure_code);
    }
    function testNewClosureCodeProperForSingleAssignmentClosure()
    {
        $init_closure = function(){$x = 1;};
        $extracto = new ExtractingClosure($init_closure);
        $closure_code = $extracto->build_closure_code_string(array());
        $this->assertEquals("function() {\$x = 1;\nreturn get_defined_vars();\n}", $closure_code);
    }
    function testNewClosureCodeProperForSingleAssignmentWithPlusMarkClosure()
    {
        $init_closure = function(){+$x = 1;};
        $extracto = new ExtractingClosure($init_closure);
        $closure_code = $extracto->build_closure_code_string(array());
        $this->assertEquals("function() {+\$x = 1;\nreturn get_defined_vars();\n}", $closure_code);
    }
    function testExposedVarNmaesEmptyIfNoMarkedVars()
    {
        $init_closure = function(){
            $x = 1;
            $y = 32;
        };
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform(array());
        $this->assertEmpty($extracto->exposed_var_names());
    }
    function testTransformExposesSingleMarkedAssignment()
    {
        $init_closure = function(){
            +$x = 1;
            $y = 42;
        };
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform(array());
        $this->assertEquals(array('x'), $extracto->exposed_var_names());
    }
    function testTransformExposedForMultipleMarkedAssignments()
    {
        $init_closure = function(){
            +$x = 1;
            $y = 42;
            +$z = 99;
        };
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform(array());
        $this->assertEquals(array('x', 'z'), $extracto->exposed_var_names());
    }
    function testTransformProperlyParsesAdditionMarks()
    {
        $init_closure = function(){
            $x = 32;
            $y = 42;
            +$z = $x +$y;
        };
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform(array());
        $this->assertEquals(array('z'), $extracto->exposed_var_names());
    }
    function testTransformProperlyParsesAdditionMarksWithRegardsToSpacing()
    {
        $init_closure = function(){
        +    $x = 32;
+$y=
    42;
+            $z = 90;
        };
        $extracto = new ExtractingClosure($init_closure);
        $extracto->transform(array());
        $this->assertEquals(array('x', 'y', 'z'), $extracto->exposed_var_names());
    }
}